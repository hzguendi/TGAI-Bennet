"""
Sample Bitcoin price monitor module for TGAI-Bennet.
This module monitors BTC/USDT price and alerts when it falls below a threshold.
"""

import aiohttp
import json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

from src.modules.base_module import BaseModule, ModuleTrigger, TriggerConfig
from src.utils.telegram_formatter import TelegramFormatter


class BTCPriceMonitorModule(BaseModule):
    """
    Bitcoin price monitor module that checks BTC/USDT price and sends alerts.
    
    This is a sample implementation of an event-triggered module that demonstrates:
    - Continuous monitoring with adjustable intervals
    - Fetching real-time price data from APIs
    - Managing price thresholds and alerts
    - Using LLM for market analysis messages
    - Tracking price history in module state
    """
    
    def __init__(self, bot_instance, config):
        super().__init__(bot_instance, config)
        
        # Module metadata
        self.description = "Monitors BTC/USDT price and alerts when below threshold"
        self.author = "TGAI-Bennet Sample Module"
        self.version = "1.0.0"
        
        # Set as event-based trigger (price check events)
        self.trigger = TriggerConfig(
            ModuleTrigger.EVENT,
            event_type='price_check'
        )
        
        # Module-specific configuration
        self.price_threshold = 30000  # Default alert threshold
        self.check_interval = 300  # Check every 5 minutes
        self.api_url = "https://api.binance.com/api/v3/ticker/price"
        self.symbol = "BTCUSDT"
        
        # Module state
        self.state = {
            'last_price': None,
            'last_check': None,
            'last_alert_price': None,
            'price_history': [],  # Track recent prices for trend analysis
            'alert_cooldown': 3600  # Minimum seconds between similar alerts
        }
        
        # Runtime variables
        self.is_running = False
    
    async def initialize(self) -> None:
        """Initialize the BTC price monitor module."""
        self.log_info("Initializing BTC Price Monitor Module")
        
        # Load configuration
        self.price_threshold = self.get_config('price_threshold', 30000)
        self.check_interval = self.get_config('check_interval', 300)
        self.api_url = self.get_config('api_url', self.api_url)
        self.symbol = self.get_config('symbol', self.symbol)
        self.state['alert_cooldown'] = self.get_config('alert_cooldown', 3600)
        
        self.log_info(f"Module configured with threshold: ${self.price_threshold:,.2f}")
    
    async def run(self) -> None:
        """Main execution method that starts the price monitoring loop."""
        if self.is_running:
            self.log_warning("Price monitor is already running")
            return
        
        self.is_running = True
        self.log_info("Starting BTC price monitoring")
        
        try:
            while self.is_running:
                # Trigger a price check event
                await self.handle_event('price_check', {})
                
                # Wait for the next check
                await asyncio.sleep(self.check_interval)
                
        except asyncio.CancelledError:
            self.log_info("Price monitoring task cancelled")
        except Exception as e:
            self.log_error(f"Error in price monitoring loop: {str(e)}", e)
        finally:
            self.is_running = False
    
    async def handle_event(self, event_type: str, event_data: Dict[str, Any]) -> None:
        """Handle price check events."""
        if event_type != 'price_check':
            return
        
        try:
            # Fetch current price
            current_price = await self._fetch_btc_price()
            
            if current_price is None:
                self.log_error("Failed to fetch BTC price")
                return
            
            # Update state
            self.state['last_price'] = current_price
            self.state['last_check'] = datetime.now().isoformat()
            
            # Add to price history (keep last 24 entries for 2-hour history at 5-min intervals)
            self._update_price_history(current_price)
            
            # Check if price is below threshold
            if current_price < self.price_threshold:
                await self._handle_price_alert(current_price)
            else:
                self.log_debug(f"BTC price ${current_price:,.2f} is above threshold")
                
        except Exception as e:
            self.log_error(f"Error handling price check event: {str(e)}", e)
    
    async def cleanup(self) -> None:
        """Clean up resources used by the module."""
        self.log_info("Cleaning up BTC Price Monitor Module")
        self.is_running = False
    
    async def _fetch_btc_price(self) -> Optional[float]:
        """
        Fetch current BTC/USDT price from API.
        
        Returns:
            Optional[float]: Current price or None if failed
        """
        try:
            async with aiohttp.ClientSession() as session:
                params = {'symbol': self.symbol}
                async with session.get(self.api_url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return float(data['price'])
                    else:
                        self.log_error(f"API returned status {response.status}")
                        return None
        except Exception as e:
            self.log_error(f"Error fetching BTC price: {str(e)}", e)
            return None
    
    def _update_price_history(self, price: float) -> None:
        """Update price history with current price."""
        history = self.state.get('price_history', [])
        history.append({
            'price': price,
            'timestamp': datetime.now().isoformat()
        })
        
        # Keep only last 24 entries
        if len(history) > 24:
            history = history[-24:]
        
        self.state['price_history'] = history
    
    def _calculate_price_trend(self) -> Dict[str, Any]:
        """Calculate price trend from history."""
        history = self.state.get('price_history', [])
        if len(history) < 2:
            return {'trend': 'unknown', 'change_percent': 0}
        
        first_price = history[0]['price']
        last_price = history[-1]['price']
        change_percent = ((last_price - first_price) / first_price) * 100
        
        if change_percent > 0:
            trend = 'up'
        elif change_percent < 0:
            trend = 'down'
        else:
            trend = 'stable'
        
        return {
            'trend': trend,
            'change_percent': change_percent,
            'period_hours': (len(history) * self.check_interval) / 3600
        }
    
    async def _handle_price_alert(self, current_price: float) -> None:
        """Handle price alert when below threshold."""
        # Check cooldown
        last_alert_time = self.state.get('last_alert_time')
        if last_alert_time:
            elapsed = (datetime.now() - datetime.fromisoformat(last_alert_time)).total_seconds()
            if elapsed < self.state['alert_cooldown']:
                self.log_debug(f"Alert cooldown active: {self.state['alert_cooldown'] - elapsed:.0f} seconds remaining")
                return
        
        # Calculate trend
        trend_data = self._calculate_price_trend()
        
        # Generate alert message using LLM
        alert_message = await self._generate_alert_message(
            current_price,
            self.price_threshold,
            trend_data
        )
        
        # Send alert
        if await self.send_telegram_message(alert_message):
            self.state['last_alert_price'] = current_price
            self.state['last_alert_time'] = datetime.now().isoformat()
            self.log_info(f"Price alert sent: ${current_price:,.2f}")
        else:
            self.log_error("Failed to send price alert")
    
    async def _generate_alert_message(
        self, 
        current_price: float, 
        threshold: float,
        trend_data: Dict[str, Any]
    ) -> str:
        """
        Generate an alert message using LLM.
        
        Args:
            current_price: Current BTC price
            threshold: Alert threshold
            trend_data: Price trend information
        
        Returns:
            str: Formatted alert message
        """
        # Create a prompt for the LLM
        system_message = (
            "You are Bennet, a cryptocurrency market assistant. "
            "Generate informative and objective price alert messages. "
            "Include market trend analysis and potential considerations."
        )
        
        trend_description = f"{trend_data['trend']} by {abs(trend_data['change_percent']):.2f}% over the past {trend_data['period_hours']:.1f} hours"
        
        prompt = (
            f"Create a Bitcoin price alert message with these details:\n"
            f"- Current BTC/USDT price: ${current_price:,.2f}\n"
            f"- Alert threshold: ${threshold:,.2f}\n"
            f"- Price is {((threshold - current_price) / threshold * 100):.1f}% below threshold\n"
            f"- Recent trend: {trend_description}\n\n"
            f"Provide a brief analysis and 1-2 considerations for traders."
        )
        
        try:
            # Generate response from LLM
            llm_response = await self.generate_llm_response(
                prompt=prompt,
                system_message=system_message,
                temperature=0.7,
                max_tokens=200
            )
            
            # Format the response for Telegram
            icon = TelegramFormatter.EMOJIS['money']
            title = f"{icon} BTC Price Alert!"
            
            # Add price chart if significant history exists
            history = self.state.get('price_history', [])
            if len(history) >= 6:  # Need at least 30 minutes of data
                sparkline = self._generate_price_sparkline(history)
                content = f"```\n{sparkline}\n```\n\n{llm_response}"
            else:
                content = llm_response
            
            return TelegramFormatter.status_message(
                title=title,
                content=content,
                status='warning'
            )
            
        except Exception as e:
            # Fallback to basic message if LLM fails
            self.log_error(f"LLM generation failed: {str(e)}", e)
            
            message = (
                f"💰 BTC Price Alert!\n\n"
                f"Current price: ${current_price:,.2f}\n"
                f"Threshold: ${threshold:,.2f}\n"
                f"Price is {((threshold - current_price) / threshold * 100):.1f}% below threshold\n\n"
                f"Trend: {trend_data['trend'].capitalize()} by {abs(trend_data['change_percent']):.2f}% over "
                f"{trend_data['period_hours']:.1f} hours"
            )
            
            return message
    
    def _generate_price_sparkline(self, history: List[Dict[str, Any]]) -> str:
        """Generate a simple ASCII sparkline chart."""
        prices = [entry['price'] for entry in history]
        min_price = min(prices)
        max_price = max(prices)
        range_price = max_price - min_price
        
        if range_price == 0:
            return "━" * len(prices)  # Flat line if no change
        
        sparkline_chars = "▁▂▃▄▅▆▇█"
        sparkline = ""
        
        for price in prices:
            # Normalize price to 0-7 range
            normalized = (price - min_price) / range_price
            char_index = int(normalized * 7)
            sparkline += sparkline_chars[char_index]
        
        # Add price labels
        first_price = prices[0]
        last_price = prices[-1]
        return f"${first_price:,.0f} {sparkline} ${last_price:,.0f}"
    
    def validate_config(self) -> bool:
        """Validate module configuration."""
        if self.price_threshold <= 0:
            self.log_error("Invalid price threshold")
            return False
        
        if self.check_interval < 60:  # Minimum 1-minute interval
            self.log_error("Check interval too short (minimum 60 seconds)")
            return False
        
        return True
    
    async def save_state(self) -> Dict[str, Any]:
        """Save the current state of the module."""
        return self.state
    
    async def load_state(self, state: Dict[str, Any]) -> None:
        """Load a previously saved state."""
        self.state = state
