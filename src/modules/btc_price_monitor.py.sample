"""
Sample BTC price monitoring module for TGAI-Bennet.
This module monitors BTC/USDT price and alerts when it crosses certain thresholds.
"""

import aiohttp
import json
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

from src.modules.base_module import BaseModule, ModuleTrigger, TriggerConfig
from src.utils.telegram_formatter import TelegramFormatter


class BTCPriceMonitorModule(BaseModule):
    """
    BTC price monitoring module that tracks BTC/USDT price and sends alerts.
    
    This is a sample implementation of an event-triggered module that demonstrates:
    - Monitoring price changes using external API
    - Threshold-based alerting
    - Price trend analysis
    - Using LLM for market commentary
    - Managing persistent state
    """
    
    def __init__(self, bot_instance, config):
        super().__init__(bot_instance, config)
        
        # Module metadata
        self.description = "Monitors BTC/USDT price and alerts on significant changes"
        self.author = "TGAI-Bennet Sample Module"
        self.version = "1.0.0"
        
        # Set as event-based trigger
        self.trigger = TriggerConfig(
            ModuleTrigger.EVENT,
            event_type='price_check',
            event_config={
                'check_interval': 60,  # Check every 60 seconds
                'source': 'binance'    # Default price source
            }
        )
        
        # Module-specific configuration
        self.price_threshold_low = 20000    # Alert if price drops below this
        self.price_threshold_high = 45000   # Alert if price rises above this
        self.percent_change_alert = 5       # Alert on 5% changes
        self.alert_cooldown = 3600         # 1 hour cooldown between similar alerts
        
        # Module state
        self.state = {
            'last_price': None,
            'last_alert_time': None,
            'last_alert_type': None,
            'price_history': [],
            'alerts_sent_today': 0
        }
        
        # Runtime data
        self.running = False
        self.check_task = None
    
    async def initialize(self) -> None:
        """Initialize the BTC price monitor module."""
        self.log_info("Initializing BTC Price Monitor Module")
        
        # Load configuration
        self.price_threshold_low = self.get_config('price_threshold_low', 20000)
        self.price_threshold_high = self.get_config('price_threshold_high', 45000)
        self.percent_change_alert = self.get_config('percent_change_alert', 5)
        self.alert_cooldown = self.get_config('alert_cooldown', 3600)
        
        self.log_info(f"Module configured: Low={self.price_threshold_low}, "
                     f"High={self.price_threshold_high}, "
                     f"Percent alert={self.percent_change_alert}%")
    
    async def run(self) -> None:
        """Main execution method that runs when the module is started."""
        self.log_info("Starting BTC price monitoring")
        self.running = True
        
        try:
            while self.running:
                await self._check_price()
                await asyncio.sleep(self.trigger.event_config.get('check_interval', 60))
                
        except asyncio.CancelledError:
            self.log_info("BTC price monitoring task cancelled")
        except Exception as e:
            self.log_error(f"Error in BTC price monitor: {str(e)}", e)
            self.running = False
    
    async def cleanup(self) -> None:
        """Clean up resources used by the module."""
        self.log_info("Cleaning up BTC Price Monitor Module")
        self.running = False
        
        if self.check_task and not self.check_task.done():
            self.check_task.cancel()
            try:
                await self.check_task
            except asyncio.CancelledError:
                pass
    
    async def _check_price(self) -> None:
        """Check current BTC price and determine if alerts are needed."""
        try:
            current_price = await self._get_btc_price()
            
            if current_price is None:
                self.log_error("Failed to get BTC price")
                return
            
            # Update price history
            self._update_price_history(current_price)
            
            # Check for alerts
            await self._check_price_alerts(current_price)
            
            # Update state
            self.state['last_price'] = current_price
            
        except Exception as e:
            self.log_error(f"Error checking BTC price: {str(e)}", e)
    
    def _update_price_history(self, price: float) -> None:
        """Update the price history with the new price."""
        timestamp = datetime.now().isoformat()
        self.state['price_history'].append({
            'timestamp': timestamp,
            'price': price
        })
        
        # Keep only last 24 hours of data
        cutoff_time = datetime.now() - timedelta(hours=24)
        self.state['price_history'] = [
            entry for entry in self.state['price_history']
            if datetime.fromisoformat(entry['timestamp']) > cutoff_time
        ]
    
    async def _check_price_alerts(self, current_price: float) -> None:
        """Check if price conditions warrant sending an alert."""
        last_price = self.state.get('last_price')
        
        # Check cooldown
        if not self._check_alert_cooldown():
            return
        
        # Check price thresholds
        if current_price <= self.price_threshold_low:
            await self._send_threshold_alert(
                current_price, 
                self.price_threshold_low, 
                'below'
            )
        elif current_price >= self.price_threshold_high:
            await self._send_threshold_alert(
                current_price, 
                self.price_threshold_high, 
                'above'
            )
        
        # Check percentage change
        if last_price:
            percent_change = ((current_price - last_price) / last_price) * 100
            
            if abs(percent_change) >= self.percent_change_alert:
                await self._send_percent_change_alert(
                    current_price, 
                    last_price, 
                    percent_change
                )
    
    def _check_alert_cooldown(self) -> bool:
        """Check if enough time has passed since the last alert."""
        last_alert = self.state.get('last_alert_time')
        if not last_alert:
            return True
        
        last_alert_time = datetime.fromisoformat(last_alert)
        time_since_alert = (datetime.now() - last_alert_time).total_seconds()
        
        return time_since_alert >= self.alert_cooldown
    
    async def _send_threshold_alert(
        self, 
        current_price: float, 
        threshold: float, 
        direction: str
    ) -> None:
        """Send alert when price crosses a threshold."""
        try:
            # Generate alert message using LLM
            alert_message = await self._generate_alert_message(
                current_price=current_price,
                threshold=threshold,
                direction=direction,
                alert_type='threshold'
            )
            
            # Send alert
            if await self.send_telegram_message(alert_message):
                self.state['last_alert_time'] = datetime.now().isoformat()
                self.state['last_alert_type'] = f'threshold_{direction}'
                self.state['alerts_sent_today'] = self.state.get('alerts_sent_today', 0) + 1
                
        except Exception as e:
            self.log_error(f"Failed to send threshold alert: {str(e)}", e)
    
    async def _send_percent_change_alert(
        self, 
        current_price: float, 
        last_price: float, 
        percent_change: float
    ) -> None:
        """Send alert when price changes by significant percentage."""
        try:
            # Generate alert message using LLM
            alert_message = await self._generate_alert_message(
                current_price=current_price,
                last_price=last_price,
                percent_change=percent_change,
                alert_type='percent_change'
            )
            
            # Send alert
            if await self.send_telegram_message(alert_message):
                self.state['last_alert_time'] = datetime.now().isoformat()
                self.state['last_alert_type'] = 'percent_change'
                self.state['alerts_sent_today'] = self.state.get('alerts_sent_today', 0) + 1
                
        except Exception as e:
            self.log_error(f"Failed to send percent change alert: {str(e)}", e)
    
    async def _get_btc_price(self) -> Optional[float]:
        """
        Fetch current BTC/USDT price from API.
        
        Returns:
            Optional[float]: Current BTC price or None if failed
        """
        try:
            # Using Binance API as an example
            url = "https://api.binance.com/api/v3/ticker/price"
            params = {"symbol": "BTCUSDT"}
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return float(data['price'])
                    else:
                        self.log_error(f"API returned status {response.status}")
                        return None
                    
        except Exception as e:
            self.log_error(f"Error fetching BTC price: {str(e)}", e)
            # Return mock price for demonstration
            return 42000.50
    
    async def _generate_alert_message(
        self,
        alert_type: str,
        **kwargs
    ) -> str:
        """
        Generate an alert message using LLM.
        
        Args:
            alert_type: Type of alert ('threshold' or 'percent_change')
            **kwargs: Alert-specific parameters
        
        Returns:
            str: Formatted alert message
        """
        # Create appropriate prompt based on alert type
        system_message = (
            "You are Bennet, a cryptocurrency price analyst. "
            "Generate informative and actionable price alert messages. "
            "Include brief market context and potential implications."
        )
        
        if alert_type == 'threshold':
            current_price = kwargs['current_price']
            threshold = kwargs['threshold']
            direction = kwargs['direction']
            
            prompt = (
                f"Create a BTC price alert message:\n"
                f"- Current price: ${current_price:.2f}\n"
                f"- Threshold: ${threshold:.2f}\n"
                f"- Direction: Price has moved {direction} the threshold\n"
                f"- Include 1-2 brief market insights or potential causes"
            )
            
            icon = 'ðŸ“‰' if direction == 'below' else 'ðŸ“ˆ'
            title = f"{icon} BTC Price Alert: {direction.title()} Threshold"
            
        elif alert_type == 'percent_change':
            current_price = kwargs['current_price']
            last_price = kwargs['last_price']
            percent_change = kwargs['percent_change']
            
            prompt = (
                f"Create a BTC price alert message:\n"
                f"- Previous price: ${last_price:.2f}\n"
                f"- Current price: ${current_price:.2f}\n"
                f"- Change: {percent_change:+.2f}%\n"
                f"- Include brief analysis of this movement and what it might mean"
            )
            
            icon = 'ðŸ“ˆ' if percent_change > 0 else 'ðŸ“‰'
            direction = 'up' if percent_change > 0 else 'down'
            title = f"{icon} BTC Price Alert: {abs(percent_change):.1f}% {direction.title()}"
        
        else:
            # Default message format
            return self._format_basic_alert(kwargs)
        
        try:
            # Generate response from LLM
            llm_response = await self.generate_llm_response(
                prompt=prompt,
                system_message=system_message,
                temperature=0.7,
                max_tokens=250
            )
            
            # Add price trend information
            trend_info = self._get_price_trend()
            
            # Format the complete message
            message_parts = [llm_response]
            
            if trend_info:
                message_parts.append(f"\n\nðŸ“Š 24h Trend: {trend_info}")
            
            message_parts.append(f"\n\nðŸ”” Alerts today: {self.state.get('alerts_sent_today', 0) + 1}")
            
            return TelegramFormatter.status_message(
                title=title,
                content='\n'.join(message_parts),
                status='warning' if 'below' in kwargs.get('direction', '') else 'info'
            )
            
        except Exception as e:
            # Fallback to basic message if LLM fails
            self.log_error(f"LLM generation failed: {str(e)}", e)
            return self._format_basic_alert(kwargs)
    
    def _get_price_trend(self) -> str:
        """Analyze price history to determine trend."""
        if not self.state.get('price_history'):
            return ""
        
        try:
            # Get prices from 24h ago and now
            history = self.state['price_history']
            oldest_price = history[0]['price']
            newest_price = history[-1]['price']
            
            # Calculate 24h change
            change_24h = ((newest_price - oldest_price) / oldest_price) * 100
            
            if change_24h > 0:
                return f"ðŸ“ˆ Up {change_24h:.1f}% in 24h"
            else:
                return f"ðŸ“‰ Down {abs(change_24h):.1f}% in 24h"
            
        except Exception as e:
            self.log_error(f"Error calculating price trend: {str(e)}", e)
            return ""
    
    def _format_basic_alert(self, kwargs: Dict[str, Any]) -> str:
        """Create a basic alert message without LLM."""
        if kwargs.get('alert_type') == 'threshold':
            current_price = kwargs['current_price']
            threshold = kwargs['threshold']
            direction = kwargs['direction']
            
            message = (
                f"{'ðŸ“‰' if direction == 'below' else 'ðŸ“ˆ'} BTC Price Alert\n\n"
                f"BTC/USDT has moved {direction} ${threshold:.0f}\n"
                f"Current price: ${current_price:.2f}"
            )
            
        elif kwargs.get('alert_type') == 'percent_change':
            current_price = kwargs['current_price']
            last_price = kwargs['last_price']
            percent_change = kwargs['percent_change']
            
            message = (
                f"{'ðŸ“ˆ' if percent_change > 0 else 'ðŸ“‰'} BTC Price Alert\n\n"
                f"Significant price movement detected!\n"
                f"Previous: ${last_price:.2f}\n"
                f"Current: ${current_price:.2f}\n"
                f"Change: {percent_change:+.2f}%"
            )
        else:
            message = "BTC Price Alert"
        
        return message
    
    def validate_config(self) -> bool:
        """Validate module configuration."""
        if self.price_threshold_low >= self.price_threshold_high:
            self.log_error("Low threshold must be less than high threshold")
            return False
        
        if self.percent_change_alert <= 0:
            self.log_error("Percent change alert threshold must be positive")
            return False
        
        return True
    
    async def save_state(self) -> Dict[str, Any]:
        """Save the current state of the module."""
        return self.state
    
    async def load_state(self, state: Dict[str, Any]) -> None:
        """Load a previously saved state."""
        self.state = state
        
        # Reset daily counter if it's a new day
        if 'alerts_sent_today' in self.state:
            last_alert = self.state.get('last_alert_time')
            if last_alert:
                last_alert_date = datetime.fromisoformat(last_alert).date()
                if last_alert_date != datetime.now().date():
                    self.state['alerts_sent_today'] = 0
